import cv2
import numpy as np
import logging
import matplotlib.pyplot as plt

def draw_lines(img, houghLines, color=[0, 0, 255], thickness=1):
    try:
        for line in houghLines:
            for rho,theta in line:
                a = np.cos(theta)
                b = np.sin(theta)
                x0 = a*rho
                y0 = b*rho
                x1 = int(x0 + 2000*(-b))
                y1 = int(y0 + 2000*(a))
                x2 = int(x0 - 2000*(-b))
                y2 = int(y0 - 2000*(a))
                cv2.line(img,(x1,y1),(x2,y2),color,thickness)
    except:
        logging.info('hough error')

cap = cv2.VideoCapture(0)

while True:
        ret, frame = cap.read()
        if not ret:
            break

        # 将图像转换为HSV颜色空间
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        # 设定蓝色和黄色的颜色范围
        lower_blue = np.array([100, 100, 100])
        upper_blue = np.array([140, 255, 255])
        lower_yellow = np.array([20, 100, 100])
        upper_yellow = np.array([30, 255, 255])

        # 根据颜色范围创建蓝色和黄色的掩模
        mask_blue = cv2.inRange(hsv, lower_blue, upper_blue)
        mask_yellow = cv2.inRange(hsv, lower_yellow, upper_yellow)

        # 寻找蓝色和黄色物体的轮廓
        contours_blue, _ = cv2.findContours(mask_blue, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contours_yellow, _ = cv2.findContours(mask_yellow, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # 在新窗口中绘制直角坐标系
        coordinate_frame = np.zeros((500, 500, 3), dtype=np.uint8)
        
        # 绘制蓝色物体的边界框并计算长度和宽度
        for contour in contours_blue:
            hull_blue = cv2.convexHull(contour)
            x, y, w, h = cv2.boundingRect(hull_blue)
            cv2.drawContours(frame, [hull_blue], -1, (255, 0, 0), 2)
            cv2.rectangle(coordinate_frame, (50, 450), (50+w, 450-h), (255, 0, 0), 2)
            cv2.putText(coordinate_frame, f'Width: {w}', (50, 470), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 1, cv2.LINE_AA)
            cv2.putText(coordinate_frame, f'Height: {h}', (50+w, 450-h-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 1, cv2.LINE_AA)
            
            ep = 15
            approx2 = cv2.approxPolyDP(hull_blue, ep, True)
            cv2.polylines(frame, [approx2], True, [0, 255, 0], 2)

        # 绘制黄色物体的边界框并计算长度和宽度
        for contour in contours_yellow:
            hull_yellow = cv2.convexHull(contour)
            x, y, w, h = cv2.boundingRect(hull_yellow)
            cv2.drawContours(frame, [hull_yellow], -1, (0, 255, 255), 2)
            cv2.rectangle(coordinate_frame, (50, 450), (50+w, 450-h), (0, 255, 255), 2)
            cv2.putText(coordinate_frame, f'Width: {w}', (50, 470), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1, cv2.LINE_AA)
            cv2.putText(coordinate_frame, f'Height: {h}', (50+w, 450-h-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1, cv2.LINE_AA)
            
             
            ep = 15
        # 拟合精度，长度小于该值的线段将被忽略
        # 该值越小则得到的轮廓中可存在的线段长度越小
            approx = cv2.approxPolyDP(hull_yellow, ep, True)
            cv2.polylines(frame, [approx], True, [0, 255, 0], 2)
        #approx2 = cv2.approxPolyDP(hull_blue, ep, True)
        #cv2.polylines(frame, [approx2], True, [0, 255, 0], 2)
        
        
         # edge
        img = cv2.Canny(frame,700,800)
        # hough
        rho = 1
        theta = np.pi/180
        threshold = 140
        hough_lines = cv2.HoughLines(img, rho, theta, threshold)
        # return
        # img_lines = np.zeros_like(img)
        draw_lines(frame, hough_lines)
        # img_lines = weighted_img(img_lines,img)
        
        
        # 显示结果
        cv2.imshow('Frame', frame)
        cv2.imshow('Coordinates', coordinate_frame)

        # 按下 'q' 键退出循环
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

cap.release()
cv2.destroyAllWindows()

